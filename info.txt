## Section 1: Introduction

1. Introduction to Testing Library and Jest
	No es solo una libreria es una filosofia, "opinionated", es lo que llamamos obstinado, lo que significa que la forma en que está escrita la biblioteca fomenta un cierto conjunto de prácticas y, en este caso, esas son las mejores prácticas para reaccionar en las pruebas.
		Testea tu soft de la manera que el usuario lo usa, no como esta escrito el soft.
			Lo que importa es si el software funciona como debería funcionar, porque el código puede cambiar, pero puede seguir comportandose igual de acuerdo a las especificaciones, entocnes los test van a seguir pasando.
	
	Encontra elementos por elementos de accesibilidad en vez de usar test ids, esto hace tu codigo sea realmente accesible (para los screen readers), por ende tu soft accesible.
	
	- Con RTL no necesitas de un browser, provee un DOM virtual para los test.
	- Jest se ocupa de:
		buscar los test, correrlos y determinar cuales pasan y cuales no.
		
	npx crea-react-app color-button
	
2. Create-React-App
	npm package
	Crea una aplicación de react con:
		configuración
		webpack y babel
		web server
		testing library
		
	npx create-react-app 
		baja siempre la ultima versión de todo
		no depende de cuando instalaste create-react-app
			nunca la instala en tu maquina
		viene con npm 5.2+ >
		si queres una version mas viena de npm y no podes hacer upgrade
			https://github.com/facebook/create-react-app siguiendo el link "instructions for older npm versions"
			https://create-react-app.dev/
			
3. First Test with Testing Library
	
	npm test 
		corre jest en watch mode:
			busca por cambios desde el ultimo commit
			solo corre los test de esos archivos
			no hay cambios, no se testea.
	
	npm test a -> corre todos los test
	npm test f -> solo failed test
	npm test q -> para salir de watch mode
	npm test p -> filtra un nombre de archivo por regex
	npm test t -> filtra el nombre de un test por regex
	
	npm test App -> este test ya lo crea-react-app
	
	
	App.test.js
	
	import {render, screen } from '@testing-library/react';
	import App from './App';
	
	test('renders learn react link', () => {
		render(<App/>);
		const linkElement = screen.getByText(/learn react/i);
		expect(linkElement).toBeInTheDocument();
	});
	
	explicación:
		render: 
			crea un virtual dom para los argumentos JSX
			accedes a ese virtual dom via screen global
			* ambos vienen de la libreria 
		screen
			screen.getByText(/learn react/i); 
			es case sensitive sin el (i) o sea, sin usar regex
			busca un elemento en el dom mediante su texto.
			puede ser una regex o no
		expect 
			hacemos assertions, o sea, causa que el test falle o sea exitoso.
			
	
4. Jest and Jest-DOM Assertions

	Las "afirmaciones" -assertions- determinan cuando un test pasa o falla.
		
	expect(linkElement).toBeInTheDocument();
		expect: jest global, comienza la afirmación
		argumento (linkElement): sujeto de la afirmación
		matcher (toBeInTheDocument()): 
			tipo de afirmación, este comparador viene del DOM de jest.
			puede o no tener argumentos que refinan el match.
		
	Afirmaciones de ejemplo:
		expect(element.textContent).toBe('hello');
		expect(elementsArray).toHaveLenght(7);
		
	jest-dom  
		es el que tiene los matchers (funciones que validan cosas) y el que corre los test.
		viene con create-react-app
		src/setupTest.js es importado antes de cada test, hace que los comparadores esten disponibles.
		DOM-based matchers, son comparadores que estan en el DOM y aplican solo al virtual dom.
			ej: toBeVisible() o toBeChecked()

5. Jest: Watch Mode and How Tests Work
	
	Ayuda a RTL, renderizando componentes en el virtual DOM mediante el metodo render.
	Ayuda en la busqueda del elementos ne el virtual DOM.
	Interactua con el virtual DOM, clickeando elementos, etc.	
	React necesita un test runner, que los busque, corra y haga afirmaciones. =  jest.
	Es recomendado por Testing Library
	Viene con create-react-app
	
	npm test corre un script npm que corre jest en watch mode.
		watch mode busca por cambios en archivos desde el ultimo commit.
		solo corre los test relacionados a ese test.
		no hay cambios? no testea
		
		o sea, si testeaste y commiteaste, después cuando corras otra vez y si no hiciste cambios, te dice que no hay test hallados para testear porque no cambio nada desde el ultimo commit.
		
		git commit -am"texto" -> shorcut: add y commit
	
	Como funciona Jest?
	
		test es un metodo global, con 2 argumentos 
		test(string descriptionDelTest, test function) 
		el test falla si cuando pasa cualquier error al correr la funcion.
		solo fallan cuando el except falla.
		un test vacio, es un test que pasa :) porque no hay error.
	
		ej:
		test('renders learn react link', () => {
		
		});
		
6. TDD: Test Driven Development

	Escribir los test antes de escribir codigo después escribis el codigo de acuerdo a las especificaciones del test, haces que el test pase.
		También se lo llama red-green test, ya que primero falla y después funciona.
		
	Escribis la funcion o sea el nombre de tu componente, sin codigo
	Escribis el test
	Haces que falle
	Escribis el codigo del componente 
	Haces pasar el test.

	Porque TDD?:
	
	 Dice que sentis una gran diferencia al escribir el test, porque lo haces parte del proceso de escribir codigo y no algo que tenes que hacer después.
	 Es mas eficiente.
	 Re run los test todo el tiempo y podes hacer pruebas de regresion, onda, fijarte que no rompiste nada de nada.

7. React Testing Library Philosophy

	Tipos de test:
	
		unit test:
			testea una unidad de codigo, una funcion o componente, en isolation. (aislado)
		
		integration test:
			como multiples partes funcionan juntos.
		
		functional test:
			testea un función particular del soft (o sea COMPORTAMIENTO) (una una funcio´n en si, sino como funciona o que hace un input cuando escribis, por ej)
			que el input sea rojo cuando pones info invalida, no validas codigo sino "comportamiento", o sea lo que ven los usuarios.
		
		acceptance / end-to-end test (e2e)
			usa un browser y un servidor, ej cypress, selenium.

8. Functional Testing vs Unit Testing

	unit testing (como esta escrito el soft)
		cuando testeas una funcion o componente, tenes que mockear las dependencias
		+ podes determinar con precisión las fallas
		- a veces te falla el test pero al usuario no le falla nada
		- a veces al usuario le falla pero a vos no el test  :happy_sad_man:
		- es mas probable a romperse por refactors.
	
	functional testing: tenes que incluir todo lo relevante a cada unidad testeada, se testea comportamiento.
		+ se acerca a como interactua el usuario, o sea que si hay fallas, seguramente el usuario tambien las tenga
		+ test mas robustos.
		- mas dificil de debuggear, porque el test no esta tan desacoplado del codigo.

9. TDD (Test Driven Development) vs BDD (Behavior Driven Development)

	TDD: (Testing Driven Development)
		como los usuarios usan la app.
		anima a testear comportamient sobre implementacion
		
	BDD: (Behavior Driven Development)
		es definido explicitamente, tienen que colaborar varios roles, desarrolladores, qa, aprtest, etc.
		define procesos de como diferentes grupos interactuan.	
		
10. Testing Library and Accessibility
	
	Se recomienda encontrar elementos por manejadores de accesbilidad.
	https://testing-library.com/docs/queries/about/#priority
	https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles
	lo que recomiendan es que si es una etiqueta a, no te quedes con usar getByText, sino que uses getByRole, esto se usa así:
		screen.getByRole('link', { name: /learn react/i});
		en este link te dice que roles son accesibles: https://www.w3.org/TR/wai-aria/#role_definitions
	
	Idealmente tu app tiene que ser friendly screen readers.
	
## Section 2: Simple App: Color Button

11. Overall Course Plan
	https://github.com/bonnie/udemy-TESTING-LIBRARY

	Focus en la sintax de RTL
	cambiar boton, deshabilitar boton
	introduce las interacciones de usuarios que afectan al dom, unit testing functions..
	crear algo mas complejo y testearlo.
	crea una segunda app para comprar helado
		teste interacciones mas complejas de usuario y componentes.
		mockea respuestas del servidor con Mock Service Worker.
		teste funcionalidad asincronica.
	
12. Start Color Button App
	
	1. Borra lo que hay en App y hace como que todavía no programo nada.
	2. Describe los test que va a testear:
		color inicial del boton.
		texto inicial.
		que cuando lo clickees cambie de color.
	3. genera el código para testear los casos.
		cuando usas getByRole el name es lo que esta escrito en esa etiqueta, ej <button>click me</button>
		con toHaveStyle va a verificar que el boton sea rojo, como supuestamente debería estar inicialmente.
	4. corre el test, y no funciona porque no hizo el código, que seria la manera correcta de hacer tdd
	5. hace el código y ejecuta el test satisfactoriamente.
	
	https://github.com/testing-library/jest-dom
	https://www.w3.org/TR/wai-aria/#role_definitions
	
13. Test that Finds Button by Role and Clicks Button
	
	Cuando no encuentra un rol te dice che, estos son los roles que tenes disponible en tu componente
	Recomienda no copiar y pegar sino hacerlo a mano así te queda la sintaxys
	
	Habla de código repetido, que podemos meter mas assertios en uno mas que nada uando haces functional testing, 
	ej verificar el estilo, lanzar un evento, verificar que este en el documento, etc...
	
	vuelve a hacer lo mismo, genera el test, fallan y después códifica.
	
	El código de ella lo va dejando acá:
		https://github.com/bonnie/udemy-TESTING-LIBRARY/tree/master/lecture-code

14. OPTIONAL React Code: Click Button to Change Color

	importa useState para poder hacer el cambio de color.
	explica que el test falla aunque parte del test esta ok, eso pasa cuando pones varios afirmaciones en una, hay que tener en cuenta eso.
	
15. Manual Acceptance Testing

	Probar que lo que se renderiza manualmente para verificar que
	realmente este pasando lo mismo que se testea.

16. Test Initial Condition of Button and Checkbox
	
	Agregó un checkbox, e hizo el test, ver código
	
17. Introduction to Code Quizzes

	Da specificaciones y pistas para crear el test
	Proposito:
		Practicar lo que aprendimos
		Reforzarlo en memoria
		Exponer areas donde sabes las respuestas
	Empezar con mucha orientación
		construir el código de los examenes con poca orientación.

	Vos elegis:
		Solo hay que codear los test (testear el codigo provisto en github
		https://github.com/bonnie/udemy-TESTING-LIBRARY/tree/master/code-quiz
		También podes código y hacer los test
	Recomienda hacer ambos (codear y testear)
		Te metes mas en como codigo y test interactuan
		Practicas debuggear test y codigo al mismo tiempo
	Opcion de usar codigo pre escrito para:
		aquellos con poco tiempo
		ayudate en debuggear cuando el codigo o el test son el problema
	
		
18. Code Quiz! Confirm Button Disable on Checkbox Check
		
	Agregar la funcionalidad del checkbox...
	Cuando el checkbox es checked, el boton debería estar deshabilitado
		Pensa como podrías hacer que el checkbox este checked en los test
		fireEvent.click
		2x en test: una vez deshabilitado el boton, volverlo a habilitar
	Afirmaciones en el boton:
		expect(button).toBeEnabled()
		expect(button).toBeDisabled()
	Nuevo test o usar el existente?	
	
	Orientación en el código de react:
		checkbox controla al boton via boolean state
			state determina el valor disabled al atributo del boton
			ella recomienda llamar al estado disabled, por default false
		onChange for checkbox
			{(e) => setDisabled(e.target.checked)}
		
19. Code Quiz Solution: Confirm Button Disable on Checkbox Check
	
	* Saltear si queres hacerlo primero, sino:
	
		Muestra el test checkbox disables button on first click and enables on second click!
		Muestra que estan fallando porque no hizo el código aún
		Lo arregla y muestra que funciona
	
20. Finding Checkbox with Label

	Le va a agregar un label al checkbox, así puede encontrar otro checkbox de haber mas de uno.

21. Code Quiz! Disabled Button Turns Gray

	Determinar que el boton sea gris cuando este disabled

	hay que usar el color "gray"
	hay que simular como el usuario puede usar la app
		deshabilitar el boton -> esta gris > habilitarlo el boton es rojo.
		click en el boton para cambiar el color - disable -> boton gris
		habilitar el boton -> azul
	las afirmaciones deben ser al final de cada flujo.

	2' muestra su solución.

22. Unit Testing Functions

	Funciones separadas del componente:
		son usadas por varios componentes
		logica compleja
	unit test si:
		la logica es complicada para testear con functional test.
		muchos casos extremos, cuando solamente queres ver que funcione la función apra estos casos.


	Dice que nuestro nuevo pedido es que los clientes esta cansados de los colores que hay y quieren otros especificos.

	Hace una función nueva en App replaceCamelWithSpaces sin código, para que falle el test.

	Comenta que la manera de agrupar test es con Describe
	Exporta la función en el archivo de test.
	Hace fallar los test, después agrega código a la función y los test funcionan.

23. Code Quiz! Update Tests for New Color Names

	quiere que en este test hagamos un test que chequee que el test arranque con el color MediumVioletRed, y cambie a MidnightBlue
	Updatear los test existentes
		espera que el comportamiento cambie
	los test de checkbox deberían seguir funcionando, onda prueba de regresion.

	1:23 da su solución.

24. When to Unit Test

	la función que hicimos puede cubrirse con test funcionales 
	para funciones mas complicadas, el test unitario auyda a:
		cubrir todo lo posible
		determinar que causa funcional puede hacer fallar los test
	el problema con los test funcionales:
		son retisentes a refactors
		puede generar problemas para detectar qué falla 

25. Review: Simple App

	Que aprendimos? 
		a testear interactividad con fireEvent
		afirmaciones con jest-dom:
			toBeEnabled
			toBeDisabled
			toBeChecked
		getByRole option { name : '' }
		jest describe para agrupar test
		unit testing functions
			como probar una función 

# Section 3: ESLint with Testing Library, plus Prettier

26. ESLint and Prettier

	ESLint es un linter
		linter es una herramienta que analiza texto estatico y marca donde se rompe la sintaxis.
		estatico: analiza como fue escrito, no que pasa cuadno corre 
		mantiene el estilo de codigo consistente
			especialmente para varios proyectos donde trabajan varias personas 
		atrapa errores en el código
			como usar una variable antes de estar definida
			importar un archivo inexistente, etc..

	Prettier es un formateador
		automaticamente formatean el código, indentación, espacios..
		ejemplo: espacios alrededor de llaves.

	
	linters 
		formato y estilo, ej:
		metodo preferido de afirmaciones con por ej toBeChecked

	Plugin extend ESLint
	testing library y jest-dom eslint plugins
		fuerza mejores Practicas
	https://github.com/testing-library/eslint-plugin-testing-library
	https://github.com/testing-library/eslint-plugin-jest-dom
	los plugins son customizables.
	
27. ESLint for Testing Library and Jest-DOM

	vamos a configurar eslint, eslint ya viene con cra
	tenemos que instalar el plugin:
	npm install eslint-plugin-testing-library eslint-plugin-jest-dom

	borra del package.json la config de eslint porque dice que es mejor tener ese tipo de configs por separado.

	crea un nuevo archivo .eslintrc.json
	agrega los plugins que queremos usar
	testing-library y jest-dom
	después agregar las reglas que quiere que se sigan tanto en los plugins como en otras extensiones
	
	react-app, react-app/jest, plugintesting-library/recommended, plugin:testing-library/react,
	plugin:jest-dom/recommended

	se pueden configurar pero ella por ahora va a usar lo recomendado.

	ella usa otras reglas mas que están en el código de su sitio web.

	https://github.com/testing-library/eslint-plugin-testing-library

	https://github.com/testing-library/eslint-plugin-jest-dom

28. Configure ESLint in VSCode

	https://code.visualstudio.com/docs/getstarted/settings#_settings-file-locations

	para hacer congis especificas para el proyecto actual, hay que crear una carpeta .vscode y adentro setting.json

	hay que verificar de tener instalada la extension eslint

	una vez que configuras, por ej, te marca los archivos en rojo que no cumplen con eslint, te fijas que te marca y sin tocar nada guardas el archivo y lo fixea solo con las recomendaciones.

	y por ultimo agrega al gitignore:
	.vscode
	.eslintcache

	también muestra en que lugar tenes que poner el settings.json si no queres hacer esto para cada proyecto yq ue aplique a todo

29. Configure Prettier in VSCode

	busca la extension y la installa
	agrega la configuración a settings.json
	y listo, cuando haces cambios en un archivo y guardas se te formatea solo

30. Review: ESLint and Prettier

	eslint
		instalar los package necesarios
		eliminar de package.json la config de eslint
		crear el archivo de config aparte
		instalar la extension para vscode
		crear la carpeta vscode y el archivo settings
		agregar a gitignore el cache de eslint y la carpeta vscode

	Prettier
		agregar la config a settings
		instalar prettier en vscode

# Section 4: Sundaes On Demand: Form Review and Popover

31. Introduction to Sundaes on Demand

	https://github.com/bonnie/udemy-TESTING-LIBRARY/tree/master/sundae-server
	crea  una nueva app
	npx create-react-app sundaes-on-demand

	la idea de la app es:
		elegir un gusto de helado y agregado (onda bañado en chocolate) y subir la orden
		los sabores y agregados, vienen del server
		la orden es enviada al servidor

	volviendo a los test:
		va a haber mas interacciones complejas
			multiples entradas moviendote en fases
		mouseover popup
			testear que el elemento desaparezca del dom
		simulación de la respuesta del servidor
			mockear service worker, para interceptar el llamado y responder lo mockeado
		async updates
			esperar cambios del dom antes de hacer una afirmación
		global state via context
			"no se supone que implementas detalles de implementación"
			no se va a testear, solo estamos interesados en testear comportamiento.
		para los test no importa si usas redux, mobx, etc...
		la única diferencia es el setup
			tenemos que asegurarnos que los componentes esten envueltos por el contexto
			asegura funcionalidad
			evita errores

		muestra los mock-ups de la app y las interacciones, pasando de fase en fase al ir comprando (onda el totem del mc)

		el "servidor", bajarse e instalar segun las instrucciones del README
		https://github.com/bonnie/udemy-TESTING-LIBRARY/tree/master/sundae-server

			es una api restful que corre en el puerto 3030
			para, manda info estatica de gustos y agregados, en una app real viene de la base..

			para el id de orden genera un nro random
			el servidor no es necesario para los test
				se va a usar mock-service-worker para mockear los Response


32. ESLint and Prettier Setup

	https://github.com/bonnie/udemy-TESTING-LIBRARY/blob/master/finished-projects/color-button/.eslintrc.json
	https://github.com/bonnie/udemy-TESTING-LIBRARY/blob/master/finished-projects/color-button/.vscode/settings.json

	hay que hacer todos los pasos anteriores, instalar los plugins sacar del package json lo de eslint, etc:
		1. instalar los plugins
			npm install eslint-plugin-testing-library eslint-plugin-jest-dom
		2. eliminar del package.json la config de eslint
		3. crear el archivo .eslintrc.json con la config:
			{
				"plugins": ["testing-library", "jest-dom"],
				"extends": [
				"react-app",
				"react-app/jest",
				"plugin:testing-library/recommended",
				"plugin:testing-library/react",
				"plugin:jest-dom/recommended"
				]
			}
		4. agregar en gitignore:
			.eslintcache
			.vscode
		5. crear la carpeta .vscode en la raiz y el archivo settings.json con la config:
			{
				"eslint.options": {
					"configFile": ".eslintrc.json"
				},
				"eslint.validate": ["javascript", "javascriptreact"],
				"editor.codeActionsOnSave": {
					"source.fixAll.eslint": true
				},
				"editor.defaultFormatter": "esbenp.prettier-vscode",
				"editor.formatOnSave": true
			}
		
		6. Probar que en App.test funcione esto (es para probar que se formatee bien y demás)
			expect(linkElement).ToHaveAttributte('checked');

			import {useEffect} from 'react'

33. React Bootstrap Setup
	en el curso se va a usar react bootstrap
		podes usar cualquier estilizador que vos quieras
	instalarlo:
		npm install react-bootstrap bootstrap
	agregar js en index.html

	De este link, se roba lo que va en index.html
		https://react-bootstrap.netlify.app/getting-started/introduction/#browser-globals
	
	De este link se roba lo que va en index.js para importar bootstrap
		https://react-bootstrap.netlify.app/getting-started/introduction/#css

	Una vez que termina solo hace un commit del archivo eslintrc (ni idea porque solo de ese..)

34. Code Organization and Introduction to SummaryForm

	Va a hacer el formulario de resumen y los test para las apariciones y desapariciones de los elementos en el dom

	las cosas que se van a testear en este formulario:
		buttons / checkbox
		popover de terminos y condiciones
			lo que hay que testear es que no este mas en la pagina
	después:
		test y código del resumen
		test y código de la funcionalidad del boton


	Organización del código por paginas
		cada pagina tendra su test
		jest va a encontrar los test y va a correr cualquiera que termine en .test.js
	src/pages/summary
		OrderSummary.jsx
		SummaryForm.jsx
	src/pages/summary/test
		SummaryForm.test.jsx

35. Code Quiz: Checkbox Enables Button

	https://github.com/bonnie/udemy-TESTING-LIBRARY/tree/master/code-quiz
	https://github.com/testing-library/jest-dom
	https://testing-library.com/docs/react-testing-library/cheatsheet/

	Escribir test para asegurarnos de:
		checkbox esta destildado por default
		checkear que el checbkox habilita el boton
		destiladar el checkbox y deshabilitar el boton
	una chance de configurar tu propio archivo de test desde 0
		usar test ya hechos como modelo
		renderizar el componente <SummaryForm>
	Buscar el checkbox y el boton usando la opción { name }
		usar mockup para name options values
	checkear que los test fallen, siemper es red-green testing

	tratar de no hacer copy/paste
		recordar usar los materiales que fue pasando los links
	si aún así lo haces, recomienda tipearlo no copiarlo, asi´queda

	no es necesario escribir el código del componente para que pase el test
		esto lo vas a hacer en la proxima lectura con ella
		tampoco espera que sepas react-bootstrap

	te hace pausar el video e intentarlo, después empieza a dar la solucion 3:13
		
36. OPTIONAL React Code: SummaryForm Checkbox and Button

	muestra el código que hizo para el componente

37. React Bootstrap Popover and Testing Library userEvent

	https://github.com/testing-library/user-event

	se fija como funciona el popover de boostrap para saber como testear, por ej, cuando pasas con el mouse esta, pero cuando sacas de encima se elimina del dom, n oes que lo ponen hidden

	fireEvent

	hay que instalar:
		npm install @testing-library/user-event @testing-library/dom
	
	esta recomendado usar userEvent sobre fireEvent, porque tiene funcionas mas avanzadas

	* userEvent es una biblioteca complementaria

	modifica los fireEvent por userEvent
	arranca con el nuevo test para el popover
	lo sigue en el proximo.

38. Screen Query Methods

	command[All]ByQueryType

	command
		get: espera que el elemento este en el DOM
		query: espera que el elemento no este en el dom
		find: espera que el elemento aparezca asincronicamente

	[All]
		(exluir) espera un solo match
		(incluido) espera mas de un match

	QueryType
		Role (mas usado)
		AltText (imagenes)
		Text (display elements)
		Form elements:
			PlaceholderText
			LabelText
			DisplayValue
	
	Referencias:
		https://testing-library.com/docs/queries/about/#priority
		https://testing-library.com/docs/react-testing-library/cheatsheet/
		https://testing-library.com/docs/queries/about/

		test id tiene que ser tu ultima opción porque los usuarios no interactuan con eso.

39. Testing Element is Not on Page: Start Popover Tests

	hace el código del test del popover
	falla porque no esta hecho el popover

40. OPTIONAL React Code: Popover

	hace el código en SummaryForm
	https://react-bootstrap.netlify.app/components/overlays/#popovers

41. "Not wrapped in act(...)" Error, Async Disappearance

	react actualiza el elemento despues de que termina el test
	no seguir ese aviso
		testing library ya hace eso por nosotros

	https://testing-library.com/docs/guide-disappearance/
	https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning
	https://testing-library.com/docs/preact-testing-library/api/#act

	para arreglar este error:
		que es lo que esta terminando después de que terminar el test?
		para el cambio:
			esperarlo
			afirmarlo
			mas info en el link de kentc

			waitForElementToBeRemoved
			ya usando eso se puede borrar la afirmación porque el metodo lo tiene incluido

42. Review: Summary Form

	flujo de los checkbox
	mouseover para terminos y condiciones
		userEvent.hover y unhover
		queryByText y not.toBeInTheDocument
		metodo asincrono waitForElementToBeRemoved
		warning act(...)
		
# Section 5: Simulating Server Response with Mock Service Worker

43. OrderEntry Server Data Introduction

44. Introduction to Mock Service Worker and Handlers

45. Setting up the Mock Service Worker Server

46. Tests with Mock Service Worker: Scoop Options

47. OPTIONAL React Code: Options and ScoopOption Components

48. Using `await findBy` to Find Elements that Populate Asynchronously

49. Code Quiz! Topping Options from Server

50. Error Server Response Planning

51. Simulating Server Error Response in Tests

52. OPTIONAL React Code: Alert Banner for Options Server Error

53. Running only Selected Tests, and `waitFor`

54. Review: Server Error Response and Test Debugging Tools

# Section 6: Testing Components Wrapped in a Provider

55. Intro to Tests for Total and Subtotals

56. Entering Text Input: Subtotal Tests

57. OPTIONAL React Code: OrderDetails Context

58. OPTIONAL React Code: Use Context to Display Scoops Subtotal

59. Adding Context to Test Setup; Test Catching Error in Code

60. Creating Custom Render to Wrap in Provider By Default

61. Review: Scoops Subtotal with Context

62. Code Quiz! Toppings Subtotal

63. OPTIONAL React Code: Toppings Checkboxes

64. Code Quiz! Grand Total

65. "Unmounted Component" Error

66. What Should Functional Tests Catch? and Refactor

# Section 7: Final Exam: Order Phases

67. Introduction to Final Exam: Order Phases

68. Adding a New Handler: Copy/Paste Warning!

69. Debugging Tips

70. OPTIONAL React Hints for Order Phase Coding

71. Final Exam Solution

72. OPTIONAL React Code: Order Phases

73. Jest Mock Functions as Props

74. Review: Final Exam, and Introduction to Optional Practice

# Section 8: Optional Extra Practice

75. Standard Questions for New Tests and Introduction to Exercises

76. Confirm "Loading" Text

77. Conditional Toppings Section on Summary Page

78. Disable Order Button if No Scoops Ordered

79. Red Input Box for Invalid Scoop Count

80. No Scoops Subtotal Update for Invalid Scoop Count

81. Server Error on Order Confirmation Page

82. Congratulations and Thank You!

